---
title: Tasks
directoryName: Sinan
inMenu: true
---

# Sinan Base Tasks

Sinan ships with a number of base tasks. Some of these tasks rely on
other tasks. Other tasks are standalone. All of them provide some
useful information. What follows is a list of default tasks and a
reasonably detailed description of what each task does and the
artifacts it creates.


# Discover

Discover is a 'prerequisite' task. It doesn't actually provide
anything that the user would be interested. However, what it does do
is very important to almost any other task that may need to
run. Basically, it searches the project directory to discover the otp
applications that make up the project.


# Depends

Depends is another 'prerequisite' task. this one, as you would
probably guess, figures out all of the dependencies for an
application. You may run it directly as needed however. Its is useful
to generate dependency information when you have connectivity and use
it when you do not.


# Build

Well, this one should be pretty obvious. It does the actual
build. However, it doesn't modify anything in the top level. It builds
all project apps into the _build/apps/<appname>-<vsn> directory. It
makes a complete copy of the application. This allows for a 'binary'
version of the application to be always available. This is good as its
used in quite a number of places.


# Test

The test task runs is another obvious task. It runs any and all
[eunit](http://support.process-one.net/doc/display/CONTRIBS/EUnit)
tasks that it finds. Assuming all eunit tests run correctly it outputs
code coverage information to _build/docs/coverage in html format.


# Doc

The doc task runs
[edoc](http://www.erlang.org/doc/doc-5.5.5/lib/edoc-0.7.1/doc/html/index.html)
across the project and outputs the information to
_build/info/docs. Unfortunately, edoc does not work in Erlang R11B-3
though it does in all versions pre and post.


# clean

Clean removes the _build directory and everything under it. It
basically removes all build artifacts from the project.


# analyze

Analyze runs dialyzer across the application. The first time it runs
it generates a plt file to _build/info/dialyzer_plt. This can take a
significant amount of time. In subsequent runs it reuses the existing
plt file. If the plt gets somehow out of date you can run 'analyze
init' to rebuild the plt file. Currently output is just to the
console.


# release

Release creates an OTP release for the file. It generates the *.rel,
*.script, and *.boot and then tars up the entire project into a
release handler tar file. It puts this in _build/tar/release.tar.gz


# dist

Dist builds up a tarball of your applications. The tar contents are in
the form <project-name>-<project-version>/lib/erlang/<apps>. It also
includes anything specified in


    dirs : {
       include_dirs : [<dir-list>]
    }


part of the configuration under the
<project-name>-<project-version>. It puts all of this in
_build/tar/dist.tar.gz.

# shell

Shell simply sets up all of the correct code paths and then starts a
shell. This way the user can fiddle with project as needed without the
setting up the paths manually.
